Assumptions:
=====================================
- SCJ library has no/minimal @Scope annotations. Stuff like ImmortalMemory
  could be annotated but is probably unnecessary.


- vendor SCJ library: 
	- vendor VM and SCJ lib implementation is not checked by the Checker
	- SCJ lib is not broken and we can determine where each "getCurrent" object lives
	       based on JSR302 spec.
	- Infrastructure code can be mutable since it must be verified by the vendor.

- Standard Java libraries shouldn't need to be annotated.
	- @Allocate(THIS)/@Allocate(CURRENT). Already in the spec, but currently unused.




Annotations and New Concepts
=====================================


@Allocate
===============================================================================================================

Applies TO:
- can be used only for methods that do return a type 
- not for methods that return "void"!  ---> if method returns "void", the @Alloc() has no effect  --> ERROR

Definition: 
   if annotated on a method @Allocate(THIS/CURRENT) specifies that the returned object from the method
              is allocated in THIS/CURRENT
Idea : 
   whenever we return an unannotated object, we could loose its scope information in the caller, therefore we need to specify it by @Allocate

DEFAULT : 
     @Allocate(CURRENT)


 @Allocate(CURRENT)
     - the method returns object that is allocated in the current allocation context
     - this means that there is somewhere "new" in the method and that resulting object will be returned...
  @Allocate(THIS)     
     - method returns a field that is allocated in the same scope as the object of that method
  @Allocate(parameter="input")
    --> the parameter must be declared in the signature
  @Allocate(scope="My_Mission")    
    --> the declared scope must exist!!
  @Allocate(scope="Immortal")
     - when returning a static object

Checking:
- we need to check that the @allocate method is placed correctly
e.g. if method returns "return this.field" and is not annotated with @Allocate(THIS), then ERROR
  (unless the default for @Allocate is THIS.)



@RunsIn(UNKNOWN)
==================================================================================================================================

- can be used also in "java.lang"

Rules:
------------------------

- method must be @RunsIn(UNKNOWN) when
	- its default @RunsIn is different then the current allocation context. 
		- the default @RunsIn is ineferred when the scope of the local variable is inferred.
	- or when an object of an unnannotated type is passed into the method as a parameter
		and the the scopes of "this" and the passed are different

- method annotated with @RunsIn(UNKNOWN) can not:
		- call getCurrent
		- store into this fields
		- store into the fields of input parameters
- executeInARea
	- each runnable used for "executeInArea" must be annotated with @RunsIn(UNKNOWN)
	- our scenario: "use executeInArea only to create new objects"
- transitivity - method calls:
	- all the methods called from a @RunsIn(UNKNOWN) method must transitively be @RunsIn(UNKNOWN)
	- 
- method overriding
	- if a method is @RunsIn(UNKNOWN) and this is method is overriden, the overriding method implicitly inherits the @RunsIn(UNKNOWN) - the annotation does not have to be restated

- TODO: constructors
        - new String?
        
- TODO: exceptions ?


String

StringBuffer - you dont want to have it crosssope or you need to use guards

@RunsIn(UNKNOWN) --> can be used also for the whole class...

q	



Guards for @RunsIn(UNKNOWN)
------------------------
case 1:
if (MemoryArea.getMemoryArea(this) == MemoryArea.getMemoryArea(b)) { 
	this.b = b;   // OK ---> field store in this is allowed because the runtime check guarantees that we are in the same scopes!
}

MemoryArea mem1 =
MemoryArea mem2 = 
if (mem1 == mem2) {
	this.b = b;
}
--->TODO: mem1, mem2, b, ... must be "final" 


case 2:
final Type x;
final MemoryArea mem = MemoryArea.getMemoryArea(x);
x.field = (Bar) mem.newInstance(Bar.class);

--->  TODO: final fields...
	
GetCurrent
----------------
@RunsIn(UNKNOWN) method can not call getCurrent(...)

- any class that does not have @Scope annotation, can not call "getCurrent" 	
---> java.* libraries are not allowed to call "getCurrent"... therefore, they do not need
to be annotated @RunsIn(UNKNOWN) to be accessible from @RunsIn(UNKNOWN) methods  ---> but you should be able to use the GUARDS!!!
	
	
			


ExecuteInArea
-------------------
executeInArea( Runnable logic )
- can only be made if the scoped memory is a parent of the current context in the scope tree
- Runnable object passed to the method must have a RunsIn annotation that matches the name of the scoped memory

each run() method used in "executeInArea" must be @RunsIn(UNKNOWN)


example:

@RunsIn(UNKNOWN) 
public method(Foo f) {
	Bar b = new Bar();
	Bar bb = new Bar(b);
	b.m(bb);
}

class Bar {

	class Bar(Bar b) {
		this.b = b;
	}
	
	public Bar b(Bar b) {
		..
		return b;
	}
}


CrossScope in java.*
-----------
- you need to use standard library that is memory safe

for 

@RunsIn(UNKNOWN)
class String {
   
	public String (String s) {
		this.s = s                 -----> here you need to use the guards
	}

    public substring(String s, ...) {
    	return new String();
    }
}



Exceptions:
---------------

  



Local Variable Scope Inference
=====================================================================================================================================================
- Implicit @scope annotation on local variables  
- only for unannotated types

Basic Principle:
- for x = getCurrent()   --> we determine the scope of returned object and assign it to the variable
- then when we see "z = x"  --> we compare the implicit scopes of the variables 
	                                and report a potential error -

Usage:
- only for unannotated types


Impact on: 
    @RunsIn! - the default @RunsIn of all of the object methods is the same as the inferred scope

Rule:
   null is of any scope   

Rules for assignment:
- If a local variable declaration has an initialization clause, the variable
  inherits the scope of the initializer expression.
- If a local variable declaration has no initialization clause, all the assignments into
  the variable must have the same scope.
- a variable of an unannotated type can not change its implicit annotation
   
   
TODO: Unknown @Scope value  
   CrossSCope = my parameters are unknown...
   @Scope("unknown")
  
  
  
   
Reference immutable:
========================

Reference Immutability
 -  for classes


Rules for reference immutability:
- A class is immutable if it has no assignments to any reference fields and it can only
call reference immutable methods. 

- A class is "really" immutable if its static call graph contains only locally
  immutable methods.
- no annotation : the checker can determine if the object is reference-immutable

PROBlEM : hard to check, 

Options:
   - use @RunsIn(UNKNOWN) in java.lang packages
   - use @ReferenceImmutable 
   - implicit checks
   - 




